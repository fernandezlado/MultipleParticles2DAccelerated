module modCell
!-------------------------------------------------------------------------------
! CALTECH, CMS, Oscar Bruno's Group
!-------------------------------------------------------------------------------
! modCell.f90 - Module that defines a Cell type and its methods. This object
! mediates between the accelerator's Reference Cells and the "low-level" 
! operations of evaluating the fields of a given obstacle.
!
! DESCRIPTION: 
!> defines Type cell and implements the ObstacleToCell and CellToObstacle
!> opertions using matrices.
!
!> @author
!> Agustin G. Fernandez-Lado
!
! MODIFIED: 15 May 2017
!-------------------------------------------------------------------------------



  use modLinearAlgebra

  use modMathConstants          

  use modObstacle

  use modProjectionReferenceCell

  use modInterpolationReferenceCell

  use modFarInteractions



  implicit none


  
  type Cell


     real(8) :: center_x, center_y

     type(Obstacle),pointer :: innerObstacle 

     complex(8),dimension(:),pointer :: psi

     complex(8),dimension(:,:),allocatable :: obsToCellMatrix_hor, obsToCellMatrix_ver
     
     complex(8),dimension(:,:),allocatable :: cellToObsMatrix
     
     complex(8),dimension(:,:),allocatable :: mon_equiv_hor, dip_equiv_hor

     complex(8),dimension(:,:),allocatable :: mon_equiv_ver, dip_equiv_ver

     complex(8),dimension(:,:),allocatable :: field_equiv_hor, field_equiv_ver


  end type Cell



contains


    
  subroutine createCell (this, c_x, c_y, obs, density, proj_refCell_hor, proj_refCell_ver, interpRefCell, k )
    
    ! --------------------------------------------------------------------------------
    ! 
    ! Class constructor. Receives as parameters the object (this) the cell's center 
    ! location (c_x, c_y), a pointer to the obstacle associated with the cell,
    ! the density in this obstacle to point to, the reference cells to
    ! construct the maps to evaluate the fields and the wavenumber k.
    !
    ! --------------------------------------------------------------------------------

    
    type(Cell) :: this

    type(InterpolationReferenceCell) :: interpRefCell

    real(8) :: c_x, c_y
    
    type (Obstacle),pointer :: obs

    complex(8),dimension(:),TARGET :: density

    type(ProjectionReferenceCell) :: proj_refCell_hor, proj_refCell_ver

    real(8) :: k


    this % center_x = c_x

    this % center_y = c_y
      
    this % psi => density


    allocate ( this % mon_equiv_hor ( 2 * proj_refCell_hor % N_src, 2 ) )

    allocate ( this % dip_equiv_hor ( 2 * proj_refCell_hor % N_src, 2 ) )

    allocate ( this % mon_equiv_ver ( 2 * proj_refCell_ver % N_src, 2 ) )

    allocate ( this % dip_equiv_ver ( 2 * proj_refCell_ver % N_src, 2 ) )

    allocate ( this % field_equiv_hor ( 2 * proj_refCell_hor % N_src, 2 ) )

    allocate ( this % field_equiv_ver ( 2 * proj_refCell_ver % N_src, 2 ) )


    this % mon_equiv_hor = 0.0d0

    this % dip_equiv_hor = 0.0d0

    this % mon_equiv_ver = 0.0d0

    this % dip_equiv_ver = 0.0d0

    this % field_equiv_hor = 0.0d0

    this % field_equiv_ver = 0.0d0


    this % innerObstacle => obs


    if ( associated ( this % innerObstacle ) .eqv. .TRUE. ) then


       allocate ( this % obsToCellMatrix_hor ( 4 * proj_refCell_hor % N_coll, &
            obs % num_dis ) )

       allocate ( this % obsToCellMatrix_ver ( 4 * proj_refCell_ver % N_coll, &
            obs % num_dis ) )


       allocate ( this % cellToObsMatrix ( obs % num_dis, &
            4 * interpRefCell % N_wave ) )


       call createObstacleToCellMatrix ( this, proj_refCell_hor, k )

       call createObstacleToCellMatrix ( this, proj_refCell_ver, k )

       call createCellToObstacleMatrix ( this, interpRefCell, k )


    end if


  end subroutine createCell



  subroutine createObstacleToCellMatrix (this, proj_refCell, k)

    ! --------------------------------------------------------------------------------
    !
    ! Computes the matrices to compute the field generated by a perfect conductor
    ! through matrix-vector multiplication.
    !
    ! --------------------------------------------------------------------------------


    type(Cell) :: this
      
    type(ProjectionReferenceCell) :: proj_refCell
      
    real(8) :: k


    real(8),allocatable,dimension(:) :: tar_x, tar_y


    allocate ( tar_x ( 1 : 4 * proj_refCell % N_coll ) )

    allocate ( tar_y ( 1 : 4 * proj_refCell % N_coll ) )


    ! --------------------------------------------------------------------------------
    ! Choose target points to construct and construct matrix
    ! --------------------------------------------------------------------------------
    
    if ( proj_refCell % cellKind == 'H' ) then

       
       tar_x ( 0 * proj_refCell % N_coll + 1 : 1 * proj_refCell % N_coll ) = &
            proj_refCell % coll_x

       tar_y ( 0 * proj_refCell % N_coll + 1 : 1 * proj_refCell % N_coll ) = &
            proj_refCell % coll_y


       tar_x ( 1 * proj_refCell % N_coll + 1 : 2 * proj_refCell % N_coll ) = &
            -proj_refCell % coll_x

       tar_y ( 1 * proj_refCell % N_coll + 1 : 2 * proj_refCell % N_coll ) = &
            proj_refCell % coll_y


       tar_x ( 2 * proj_refCell % N_coll + 1 : 3 * proj_refCell % N_coll ) = &
            -proj_refCell % coll_x

       tar_y ( 2 * proj_refCell % N_coll + 1 : 3 * proj_refCell % N_coll ) = &
            -proj_refCell % coll_y


       tar_x ( 3 * proj_refCell % N_coll + 1 : 4 * proj_refCell % N_coll ) = &
            proj_refCell % coll_x

       tar_y ( 3 * proj_refCell % N_coll + 1 : 4 * proj_refCell % N_coll ) = &
            -proj_refCell % coll_y


       !translate reference Cell to a Cell centered at (center_x, center_y)

       tar_x = this % center_x + tar_x

       tar_y = this % center_y + tar_y


       call createEvalFieldAtPointsMatrix ( &
            this % obsToCellMatrix_hor, &
            this % innerObstacle, &
            tar_x, tar_y, &
            k)


    else if ( proj_refCell % cellKind == 'V' ) then


       tar_x ( 0 * proj_refCell % N_coll + 1 : 1 * proj_refCell % N_coll ) = &
            proj_refCell % coll_x

       tar_y ( 0 * proj_refCell % N_coll + 1 : 1 * proj_refCell % N_coll ) = &
            proj_refCell % coll_y


       tar_x ( 1 * proj_refCell % N_coll + 1 : 2 * proj_refCell % N_coll ) = &
            proj_refCell % coll_x

       tar_y ( 1 * proj_refCell % N_coll + 1 : 2 * proj_refCell % N_coll ) = &
            -proj_refCell % coll_y


       tar_x ( 2 * proj_refCell % N_coll + 1 : 3 * proj_refCell % N_coll ) = &
            -proj_refCell % coll_x

       tar_y ( 2 * proj_refCell % N_coll + 1 : 3 * proj_refCell % N_coll ) = &
            -proj_refCell % coll_y


       tar_x ( 3 * proj_refCell % N_coll + 1 : 4 * proj_refCell % N_coll ) = &
            -proj_refCell % coll_x

       tar_y ( 3 * proj_refCell % N_coll + 1 : 4 * proj_refCell % N_coll ) = &
            proj_refCell % coll_y

       
       !translate reference Cell to a Cell centered at (center_x, center_y)
            
       tar_x = this % center_x + tar_x

       tar_y = this % center_y + tar_y


       call createEvalFieldAtPointsMatrix ( &
            this % obsToCellMatrix_ver, &
            this % innerObstacle, &
            tar_x, tar_y, &
            k)

    end if

    
    deallocate ( tar_x, tar_y ) 


  end subroutine createObstacleToCellMatrix



  subroutine createCellToObstacleMatrix (this, refCell, k)

    ! --------------------------------------------------------------------------------
    !
    ! Computes the matrix to interpolate the field at the obstacle inside the cells
    ! using a plane wave expansion
    !
    ! --------------------------------------------------------------------------------


    type(Cell) :: this

    type(InterpolationReferenceCell) :: refCell

    real(8) :: k

    
    real(8),dimension(:,:),allocatable :: U_x, U_y, P_x, P_y

    integer :: N_row, N_col, N_w

    
    N_row = this % innerObstacle % num_dis

    N_w = refCell % N_wave

    N_col = 4 * N_w


    allocate ( U_x ( 1 : N_row, 1 : N_w ), U_y ( 1 : N_row, 1 : N_w ) )

    allocate ( P_x ( 1 : N_row, 1 : N_w ), P_y ( 1 : N_row, 1 : N_w ) )


    U_x = spread ( refCell % U_x, 1, N_row )

    U_y = spread ( refCell % U_y, 1, N_row )


    P_x = spread ( this % innerObstacle % C_x - this % center_x, 2, N_w )

    P_y = spread ( this % innerObstacle % C_y - this % center_y, 2, N_w )


    this % cellToObsMatrix ( : , 0 * N_w + 1 : 1 * N_w ) = &
         EXP ( I * k * ( P_x * U_x + P_y * U_y ) )

    this % cellToObsMatrix ( : , 1 * N_w + 1 : 2 * N_w ) = &
         EXP ( I * k * (-P_x * U_x + P_y * U_y ) )

    this % cellToObsMatrix ( : , 2 * N_w + 1 : 3 * N_w ) = &
         EXP ( I * k * (-P_x * U_x - P_y * U_y ) )

    this % cellToObsMatrix ( : , 3 * N_w + 1 : 4 * N_w ) = &
         EXP ( I * k * ( P_x * U_x - P_y * U_y ) )


    deallocate ( U_x, U_y )

    deallocate ( P_x, P_y )


  end subroutine createCellToObstacleMatrix



  subroutine computeFieldInCollocationPoints ( this, hor, ver )


    type(Cell) :: this

    complex(8),dimension(:) :: hor, ver


    call MatVecMultiply ( this % obsToCellMatrix_hor, this % psi, hor )

    call MatVecMultiply ( this % obsToCellMatrix_ver, this % psi, ver )


  end subroutine computeFieldInCollocationPoints



  subroutine computeFieldAtInnerObstacle ( this, xi, field )


    type(Cell) :: this
    
    complex(8),dimension(:) :: xi, field


    call MatVecMultiply ( this % cellToObsMatrix, xi, field )


  end subroutine computeFieldAtInnerObstacle



  subroutine destroyCell (this)


    type(Cell) :: this


    nullify ( this % innerObstacle )

    deallocate ( this % obsToCellMatrix_hor, this % obsToCellMatrix_ver )

    deallocate ( this % cellToObsMatrix )


  end subroutine destroyCell



end module modCell
